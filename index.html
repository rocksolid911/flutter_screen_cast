<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Cast Receiver</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #screen-display {
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            z-index: 1000;
        }
        
        #waiting-message {
            text-align: center;
            font-size: 48px;
            color: #fff;
        }
        
        .status-connected {
            color: #00ff00;
        }
        
        .status-waiting {
            color: #ffff00;
        }
        
        .status-error {
            color: #ff0000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="status" class="status-waiting">ðŸ“± Waiting for phone connection...</div>
        
        <div id="waiting-message">
            <h1>ðŸŽ¬ Screen Cast Receiver</h1>
            <p>Ready to receive screen from your Flutter app!</p>
            <p id="connection-info">Initializing...</p>
        </div>
        
        <img id="screen-display" alt="Phone Screen" />
    </div>

    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <script>
        console.log('ðŸš€ Screen Cast Receiver starting...');
        
        // Initialize Cast Receiver
        const castReceiverContext = cast.framework.CastReceiverContext.getInstance();
        const playerManager = castReceiverContext.getPlayerManager();
        
        // Set up custom message namespace - THIS MUST MATCH YOUR FLUTTER APP!
        const SCREEN_CAST_NAMESPACE = 'urn:x-cast:com.isvisoft.flutter_screen_recording';
        
        // UI elements
        const statusDiv = document.getElementById('status');
        const waitingMessage = document.getElementById('waiting-message');
        const screenDisplay = document.getElementById('screen-display');
        const connectionInfo = document.getElementById('connection-info');
        
        function updateStatus(message, className = 'status-waiting') {
            statusDiv.textContent = message;
            statusDiv.className = className;
            console.log('ðŸ“± Status:', message);
        }
        
        function updateConnectionInfo(info) {
            connectionInfo.textContent = info;
        }
        
        // Handle custom messages from your Flutter app
        castReceiverContext.addCustomMessageListener(SCREEN_CAST_NAMESPACE, (customEvent) => {
            console.log('ðŸ“¨ Received message from Flutter app:', customEvent);
            
            try {
                const message = JSON.parse(customEvent.data);
                console.log('ðŸ“‹ Parsed message:', message);
                
                switch (message.type) {
                    case 'test':
                        console.log('âœ… Test message received:', message.message);
                        updateStatus('ðŸ“± Connected to Flutter app!', 'status-connected');
                        updateConnectionInfo(`Test: ${message.message}`);
                        
                        // Send response back to Flutter app
                        customEvent.sendMessage({
                            type: 'test_response',
                            status: 'success',
                            message: 'TV received your test message!'
                        });
                        break;
                        
                    case 'screen_frame':
                        console.log('ðŸ–¼ï¸ Screen frame received, size:', message.data?.length || 0);
                        updateStatus('ðŸŽ¬ Casting screen...', 'status-connected');
                        
                        if (message.data) {
                            // Display the screen frame
                            screenDisplay.src = 'data:image/jpeg;base64,' + message.data;
                            screenDisplay.style.display = 'block';
                            waitingMessage.style.display = 'none';
                            
                            updateConnectionInfo(`Frame: ${message.timestamp}`);
                        }
                        break;
                        
                    case 'stop_casting':
                        console.log('ðŸ›‘ Stop casting received');
                        updateStatus('ðŸ“± Casting stopped', 'status-waiting');
                        screenDisplay.style.display = 'none';
                        waitingMessage.style.display = 'block';
                        updateConnectionInfo('Casting stopped');
                        break;
                        
                    default:
                        console.log('â“ Unknown message type:', message.type);
                        updateStatus('â“ Unknown message received', 'status-error');
                }
                
            } catch (error) {
                console.error('âŒ Error parsing message:', error);
                updateStatus('âŒ Message parsing error', 'status-error');
            }
        });
        
        // Handle sender connections
        castReceiverContext.addEventListener(
            cast.framework.system.EventType.SENDER_CONNECTED,
            (event) => {
                console.log('ðŸ“± Sender connected:', event.senderId);
                updateStatus('ðŸ“± Phone connected!', 'status-connected');
                updateConnectionInfo(`Connected: ${event.senderId}`);
            }
        );
        
        castReceiverContext.addEventListener(
            cast.framework.system.EventType.SENDER_DISCONNECTED,
            (event) => {
                console.log('ðŸ“± Sender disconnected:', event.senderId);
                updateStatus('ðŸ“± Phone disconnected', 'status-waiting');
                updateConnectionInfo('Disconnected');
                
                // Hide screen display when disconnected
                screenDisplay.style.display = 'none';
                waitingMessage.style.display = 'block';
            }
        );
        
        // Handle ready event
        castReceiverContext.addEventListener(
            cast.framework.system.EventType.READY,
            () => {
                console.log('âœ… Cast Receiver ready!');
                updateStatus('âœ… Ready for connections', 'status-waiting');
                updateConnectionInfo('Ready to receive');
            }
        );
        
        // Start the receiver
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true; // Keep running even when idle
        
        console.log('ðŸŽ¬ Starting Cast Receiver with options:', castReceiverOptions);
        castReceiverContext.start(castReceiverOptions);
        
        // Debug: Log all available namespaces
        console.log('ðŸ“‹ Registered custom namespace:', SCREEN_CAST_NAMESPACE);
        
        // Test function for debugging
        window.testReceiver = function() {
            console.log('ðŸ§ª Testing receiver...');
            updateStatus('ðŸ§ª Test mode active', 'status-connected');
            updateConnectionInfo('Test mode');
        };
        
        console.log('ðŸŽ¬ Screen Cast Receiver initialized!');
        console.log('ðŸ“‹ Listening for messages on namespace:', SCREEN_CAST_NAMESPACE);
    </script>
</body>
</html>
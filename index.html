<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Screen Mirror Cast Receiver - App ID: 7D1A32C2</title>
    <!-- Add CORS meta tag to help with image loading -->
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <style>
        // ...existing code...
    </style>
</head>
<body>
    <div class="container">
        <img id="screen" class="screen-image" crossorigin="anonymous" />

        <!-- Debug and test panels remain unchanged -->
        // ...existing code...
    </div>

    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <script>
        // Counters and state
        // ...existing code...

        // Elements
        // ...existing code...

        // Image event listeners for debugging
        screenEl.onload = function() {
            log('✅ Image loaded successfully!');
            imageStatusEl.textContent = 'Loaded ✅';
            imageDemsEl.textContent = `${this.naturalWidth}x${this.naturalHeight}`;
            imageSrcLenEl.textContent = this.src.length;
        };

        screenEl.onerror = function(e) {
            logError('❌ Image failed to load: ' + e.type);
            imageStatusEl.textContent = 'Failed ❌';
            // Try to recover with a delayed retry
            setTimeout(() => {
                if (lastImageData) {
                    log('🔄 Retrying failed image load...');
                    displayFrame(lastImageData);
                }
            }, 500);
        };

        // ...existing code...

        // Initialize cast receiver
        function initReceiver() {
            try {
                log('🚀 Starting enhanced Cast receiver with debugging');
                updateStatus('Starting...');

                const options = new cast.framework.CastReceiverOptions();
                options.disableIdleTimeout = true;
                
                // Add custom messaging options
                options.customNamespaces = {
                    'urn:x-cast:com.isvisoft.flutter_screen_recording': cast.framework.system.MessageType.STRING
                };

                const context = cast.framework.CastReceiverContext.getInstance();

                // ...existing code...

                // Listen on the custom namespace with more robust error handling
                context.addCustomMessageListener('urn:x-cast:com.isvisoft.flutter_screen_recording', (event) => {
                    try {
                        log(`📨 Received message from sender: ${event.senderId}`);
                        handleMessage(event.data);
                    } catch (err) {
                        logError(`💥 Critical error in message listener: ${err.message}`);
                        console.error(err);
                    }
                });

                // Start with debug logging enabled
                context.start(options);
                log('✅ Receiver initialized successfully');

            } catch (e) {
                logError('❌ Initialization failed: ' + e.message);
                updateStatus('Init failed');
            }
        }

        // Handle incoming messages with improved error handling
        function handleMessage(data) {
            try {
                messageCount++;
                messageCountEl.textContent = messageCount;

                log(`📨 Message #${messageCount} received`);
                
                // Show raw data
                showRawMessage(data);

                // Get data size
                const dataSize = typeof data === 'string' ? data.length : JSON.stringify(data).length;
                dataSizeEl.textContent = `${dataSize} bytes`;
                log(`📏 Message size: ${dataSize} bytes`);

                let message;
                if (typeof data === 'string') {
                    try {
                        message = JSON.parse(data);
                        msgTypeEl.textContent = message.type || 'unknown';
                        log(`📋 Message type: ${message.type}`);

                        if (message.type === 'screen_frame' && message.data) {
                            log('🎯 Processing screen_frame message');
                            
                            const imageData = message.data;
                            log(`🖼️ Image data length: ${imageData.length}`);
                            
                            // Validate base64
                            const isValidBase64 = validateBase64(imageData);
                            base64ValidEl.textContent = isValidBase64 ? 'Valid ✅' : 'Invalid ❌';
                            log(`🔍 Base64 valid: ${isValidBase64}`);
                            
                            if (isValidBase64) {
                                displayFrame(imageData);
                            } else {
                                logError('❌ Invalid base64 data received');
                                // Try to fix common base64 issues
                                const fixedData = fixBase64Data(imageData);
                                if (fixedData !== imageData) {
                                    log('🔧 Attempting with fixed base64 data...');
                                    displayFrame(fixedData);
                                }
                            }
                        } else {
                            log(`⚠️ Unknown/incomplete message: ${JSON.stringify(message).substring(0, 200)}`);
                        }
                    } catch (jsonError) {
                        logError('❌ JSON parsing error: ' + jsonError.message);
                        log(`📄 Raw data preview: ${data.substring(0, 200)}...`);
                        
                        // Try to extract base64 data with regex - more robust pattern
                        const dataMatch = data.match(/"data":"([^"]+?)(?:","timestamp|"})/);
                        if (dataMatch && dataMatch[1]) {
                            log('🎯 Extracted data with regex');
                            const imageData = dataMatch[1];
                            const isValidBase64 = validateBase64(imageData);
                            base64ValidEl.textContent = isValidBase64 ? 'Valid ✅' : 'Invalid ❌';
                            
                            if (isValidBase64) {
                                displayFrame(imageData);
                            }
                        }
                    }
                } else {
                    logError('❌ Received non-string message');
                }
            } catch (e) {
                logError('❌ Error handling message: ' + e.message);
                console.error('Full error:', e);
            }
        }

        // Fix common base64 issues
        function fixBase64Data(str) {
            // Replace URL-safe chars with standard base64 chars
            return str.replace(/-/g, '+').replace(/_/g, '/');
        }

        // Validate base64 string with better error handling
        function validateBase64(str) {
            if (!str) return false;
            
            try {
                // Check if it looks like base64 (valid chars and length)
                if (!/^[A-Za-z0-9+/=]+$/.test(str)) {
                    return false;
                }
                
                // Check if it can be decoded/encoded
                return btoa(atob(str)) === str;
            } catch (e) {
                console.error('Base64 validation error:', e);
                return false;
            }
        }

        // Display the frame on screen with better error handling
        function displayFrame(base64Data) {
            try {
                log('🎬 Attempting to display frame...');
                
                lastImageData = base64Data;
                lastDecodeEl.textContent = new Date().toLocaleTimeString();
                
                // Set image status to loading
                imageStatusEl.textContent = 'Loading...';
                
                // Create the data URL with explicit MIME type
                const dataUrl = 'data:image/jpeg;base64,' + base64Data;
                log(`🔗 Data URL length: ${dataUrl.length}`);
                
                // Set the image source with error handling
                const img = new Image();
                img.onload = function() {
                    // When pre-loading succeeds, update the visible image
                    screenEl.src = dataUrl;
                    log('✅ Image pre-loaded successfully');
                    
                    frameCount++;
                    framesEl.textContent = frameCount;
                    updateStatus('Streaming');
                };
                
                img.onerror = function(e) {
                    logError(`❌ Image pre-load failed: ${e.type}`);
                    // Still try to set it directly as a fallback
                    screenEl.src = dataUrl;
                };
                
                // Start loading the image
                img.src = dataUrl;

            } catch (e) {
                logError('❌ Display error: ' + e.message);
                imageStatusEl.textContent = 'Error ❌';
            }
        }

        // ...existing code...

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            log('🎯 DOM loaded, checking Cast framework...');
            
            if (typeof cast !== 'undefined' && cast.framework) {
                log('✅ Cast framework found');
                initReceiver();
            } else {
                logError('❌ Cast framework not found');
                updateStatus('Cast SDK missing');
                
                // More aggressive retry
                let retryCount = 0;
                const maxRetries = 5;
                const retryInterval = setInterval(() => {
                    retryCount++;
                    log(`🔄 Retry attempt ${retryCount}/${maxRetries} to load Cast framework...`);
                    
                    if (typeof cast !== 'undefined' && cast.framework) {
                        log('✅ Cast framework loaded on retry');
                        clearInterval(retryInterval);
                        initReceiver();
                    } else if (retryCount >= maxRetries) {
                        clearInterval(retryInterval);
                        logError('❌ Cast framework could not be loaded after retries');
                    }
                }, 2000);
            }
        });

        // Test with sample image on startup
        setTimeout(() => {
            log('🧪 Auto-testing with sample image in 3 seconds...');
            testImage();
        }, 3000);
    </script>
</body>
</html>
